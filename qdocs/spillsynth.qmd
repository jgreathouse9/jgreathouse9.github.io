---
title: "Synthetic Controls With More Than One Outcome"
date: 2025-04-16
categories: [Causal Inference, Econometrics]
---

This will be a short blog post. I've spent the last two months doing a little industry work in the marketing realm, and in the meantime I have made some substantial changes to ```mlsynth```. This blog post simply shows one of the new key features I have implemented. Chances are if you're reading this, you know what I mean by the notation of SUTVA, or the stable unit treatment value assumption. It's the idea that if we care about the causal impact of a treatment on a unit, but other units are affected by the treatment or otherwise experience a similar treatment, that this exposure confounds our treatment effect with respect to the original unit we do care about. Say we wish to study the impact of German Reunification on West Germany's GDP. We know West Germany was exposed, but what about neighboring nations like Austria or France? What if the reunificaion had regional effects? Analysts therefore have a problem: Austria and France may be very similar to West Germany, and therefore informative of West Germany's counterfactual, but we are concerned they are exposed. What do we do? Before, researchers would need to drop these units or argue for their inclusion/exclusion, despite them being treated. Now, we do not need to do that, as SCM has a few approaches that deal with spillovers (this post covers just [one](https://arxiv.org/abs/2405.01645)). The approach, called iterative synthetic controls, is deceptively simple.

Say we think Austria and France are treated, partly. Step one is to estimate a synthetic control for Austria, including France as a donor but excluding West Germany. Which SCM you ask? Any one you like! For the purposes of this post, we will be using the Robsut SCM and the Robust PCA SCM methods from ```mlsynth```. The precise details are not important, but you may [read the docs](https://mlsynth.readthedocs.io/en/latest/clustersc.html) should you like.  We then take the model predictions for Austria across the full pre and post period and replace the original Austria with the synthetic control values. Next, we do France: **using the cleaned up Austria as a donor**, we estimate the synthetic control for France, using the now-cleaned Austria and the remaining 14 donor pool units. As before, we replace the values for the original France with the new synthetic France. We now have cleaned up our two donors that may be exposed to the treatment. Now, with these two cleaned donors, we estimate the counterfactual for West Germany, with our 14 totally unexposed donors and the two now cleaned up donors that were once partially exposed.

# Estimation in Python

"But Jared!", you'll say, this seems like a lot of looping and lots of donor tracking. Well fear not, that's what ```mlsynth``` is for. In order to get these results, you need Python (3.9 or greater) and ``mlsynth``, which you may install from the Github repo. You'll need the most recent version.

```bash
pip install -U git+https://github.com/jgreathouse9/mlsynth.git
```

First we estimate the orignal model. You'll find our handy-dandy util function ```iterative_scm``` is now imported.

```{python}

#| fig-align: center


import pandas as pd
from mlsynth import CLUSTERSC
from mlsynth.utils.spillover import iterative_scm

# Load the reunification dataset
url = "https://raw.githubusercontent.com/jgreathouse9/mlsynth/main/basedata/german_reunification.csv"
df = pd.read_csv(url)

# Define configuration for CLUSTERSC
config = {
    "df": df,
    "outcome": "gdp",          # per capita GDP
    "treat": "Reunification",     # binary treatment indicator
    "unitid": "country",          # country name
    "time": "year",               # time variable
    "display_graphs": True,       # display counterfactual plots
    "save": False,
    "counterfactual_color": ["red", "blue"],
    "method": "BOTH",              # use principal components regression
    "Frequentist": True
}

originalresults = CLUSTERSC(config).fit()

```
These are the original results., You may check them against [my coworker's dissertation](https://academicworks.cuny.edu/cgi/viewcontent.cgi?article=6069&context=gc_etds) if you wish. Now we see how sensitive the results are to adjusting for spillover effects.

```{python}

#| fig-align: center

# Run iterative SCM
iSCM_result = iterative_scm(CLUSTERSC(config), spillover_unit_identifiers=["Austria", "France"])

```

You pass the original ```config``` to the util function, and you pass a list of strings that denote which units we believe are partly treated. Form there, the algorithm under the hood handles the donor cleaning, and returns back the results of the final SCM run with both donors cleaned.


| Estimator | Donor Cleaning | Pre-Treatment RMSE | Post-Treatment RMSE | ATT      |
|-----------|----------------|--------------------|----------------------|----------|
| PCR       | No             | 98.698             | 1870.339             | -1962.635 |
| PCR       | Yes            | 105.499            | 1910.530             | -2055.579 |
| RPCA      | No             | 88.603             | 1482.419             | -1500.934 |
| RPCA      | Yes            | 89.189             | 1508.943             | -1604.434 |


We can see that the results are very similar. Both results are quite similar, with the pre-treatment fits degrading only very slightly (even more so with the Robust PCA method, highlighting its robustness to tiny tweaks in the model). Speaking of which, the new weights are 'Denmark': 0.032, 'France': 0.855, 'Norway': 0.105, 'New Zealand': 0.03, whereas before they were 'Austria': 0.023, 'France': 0.354, 'Norway': 0.485, 'New Zealand': 0.296. Austria goes away as a weighed donor, but there's not very much change in the pre-treatment fit or the practical conclusions we draw from the analysis.


# Comments

So, this is not the only way to do this. There are [plenty](https://arxiv.org/pdf/2403.17624) [of](https://arxiv.org/pdf/1902.07343) [other methods](https://academic.oup.com/jrsssa/article/188/1/223/7639151) that [people](https://arxiv.org/pdf/2501.08231) have [developed](https://arxiv.org/pdf/2505.00331) for this purpose too. I likely will not program all of thse myself into ```mlsynth```, but others who are so inclined are welcome to assist in the effort! in the future, I'll also allow you to switch between the options for each kind of spillover management (the inclusive method versus the iterative method, for example). But, now you know how to use this for your own work. As usual, comments or suggestions are always appreciated.
