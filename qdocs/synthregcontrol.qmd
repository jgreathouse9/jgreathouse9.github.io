---
title: 'A Novel Two Stage Synthetic Control Method'
date: 2025-04-06
categories: [Causal Inference, Econometrics]
---
I define.

# Notation

Let $\mathbb{R}$ denote the set of real numbers. A calligraphic letter, such as $\mathcal{S}$, represents a discrete set with cardinality $S = |\mathcal{S}|$. Let $\mathbf{C}_T \in \mathbb{R}^{T \times T}$ represent the centering matrix defined as:

$$
\mathbf{C}_T \coloneqq \mathbf{I}_T - \frac{1}{T} \mathbf{1}_T \mathbf{1}_T^\top
$$

Where $\mathbf{I}_T$ is the identity matrix of size $T$, and $\mathbf{1}_T \in \mathbb{R}^T$ is the vector of ones of length $T$.For any vector $\mathbf{x} \in \mathbb{R}^T$, the demeaned version is:

$$
\widetilde{\mathbf{x}} \coloneqq \mathbf{C}_T \mathbf{x}
$$ 

Let $j \in \mathbb{N}$ represent indices for a total of $N$ units and $t \in \mathbb{N}$ index time. Let $j = 1$ be the treated unit, with the set of controls being $\mathcal{N}_0 = \mathcal{N} \setminus \{1\}$, with cardinality $N_0$. The pre-treatment period consists of the set $\mathcal{T}_1 = \{ t \in \mathbb{N} : t \leq T_0 \}$, where $T_0$ is the final period before treatment. Similarly, the post-treatment period is given by $\mathcal{T}_2 = \{ t \in \mathbb{N} : t > T_0 \}$. The observed outcome for unit $j$ at time $t$ is $y_{jt}$, where a generic outcome vector for a given unit in the dataset is $\mathbf{y}_j \in \mathbb{R}^T$, where $\mathbf{y}_j = (y_{j1}, y_{j2}, \dots, y_{jT})^\top \in \mathbb{R}^{T}$. The outcome vector for the treated unit specifically is $\mathbf{y}_1$. The donor matrix, similarly, is defined as $\mathbf{Y}_0 \coloneqq \begin{bmatrix} \mathbf{y}_j \end{bmatrix}_{j \in \mathcal{N}_0} \in \mathbb{R}^{T \times N_0}$, where each column indexes a donor unit and each row is indexed to a time period.

## Synthetic Controls

Before I get to the SRC, I review synthetic controls. Let $\mathbf{y}_1 \in \mathbb{R}^T$ represent the outcome vector of the treated unit, where we seek to estimate the counterfactual outcomes in the post-treatment period (i.e., for $t > T_0$). We define the synthetic control as a weighted sum of the donor units' outcome vectors $\mathbf{y}_j$, where $j \in \mathcal{N}_0$. Specifically, we use a weight vector $\mathbf{w} \in \mathbb{R}^{N_0}$ to form the synthetic control, such that the counterfactual outcome for the treated unit is

$$
\mathbf{y}_1^{\text{SC}} = \mathbf{Y}_0 \mathbf{w}
$$

where $\mathbf{y}_1^{\text{SC}}$ is the predicted counterfactual outcome for the treated unit, $\mathbf{Y}_0 \in \mathbb{R}^{T \times N_0}$ is the matrix of outcome vectors for the donor units, and $\mathbf{w} \in \mathbb{R}^{N_0}$ is the vector of weights applied to each donor unit. The goal is to find $\mathbf{w}$ that best approximates the outcome vector of the treated unit during the pre-treatment period.

The weights are estimated by minimizing the distance between the treated unit's pre-treatment outcomes $\mathbf{y}_{1,\text{pre}}$ and the weighted average of the donor units' pre-treatment outcomes. This can be expressed as

$$
\min_{\mathbf{w}} \left\| \mathbf{y}_{1,\text{pre}} - \mathbf{Y}_{0,\text{pre}} \mathbf{w} \right\|_2^2
$$

where $\mathbf{y}_{1,\text{pre}} \in \mathbb{R}^{T_0}$ is the pre-treatment outcome vector for the treated unit and $\mathbf{Y}_{0,\text{pre}} \in \mathbb{R}^{T_0 \times N_0}$ is the pre-treatment outcome matrix for the donor units. The objective is to minimize the mean squared error (MSE) between the pre-treatment outcomes of the treated unit and the synthetic control.

$$
\mathcal{W} = \left\{ \mathbf{w} \in \mathbb{R}^{N_0} : \mathbf{w} \geq 0, \|\mathbf{w}\|_1 = 1 \right\}
$$

Once the weights $\mathbf{w}$ are estimated, the counterfactual outcome for the treated unit during the post-treatment period is given by

$$
\mathbf{y}_{1,t}^{\text{SC}} = \mathbf{Y}_0 \mathbf{w}, \quad \text{for } t > T_0
$$

Thus, the counterfactual outcome for each time period in the post-treatment period is the weighted sum of the donor units' outcomes, with the weights derived from the pre-treatment period.

# Synthetic Regression Control (SRC)

SRC is a penalized regression approach to estimating synthetic control models. In the first step, we begin by estimating what the original paper calls the alignment coefficients $\hat{\boldsymbol{\theta}}_j$ for each donor unit. Often, we believe that some control units may have level differences between the target unit and donor units. So, we first demean our target vector and donor pool in the pre-treatment period. This is done through via univariate OLS. We use the outcome vector of each donor unit in univariate regression to precict the pre-treatment outcomes of the treated unit. Because we've demeaned everything, the constant by definition is 0, leaving is with this result:

$$
\hat{\boldsymbol{\theta}} = \left( \widetilde{\mathbf{Y}}_0^\top \widetilde{\mathbf{Y}}_0 \right)^{-1} \widetilde{\mathbf{Y}}_0^\top \widetilde{\mathbf{y}}_1
$$

where $\widetilde{\mathbf{Y}}_0$ is the matrix of demeaned donor unit outcomes and $\widetilde{\mathbf{y}}_1$ is the demeaned outcome of the treated unit. The resulting $\hat{\boldsymbol{\theta}}$ values represent how closely each donor unit’s trajectory matches that of the treated unit in the pre-treatment period. These coefficients quantify how well each donor unit’s demeaned outcome aligns with the treated unit’s demeaned outcome. Naturally, a higher theta suggests that the donor unit is more aligned with the target unit. Importantly, the whole point is this step is to reduce interpolation biases by penalizing poor fitting donors.

In the second stage, we determine the unit weights $\hat{\mathbf{w}}_j$ that define the synthetic control using the vector of thetas we've estimated above. These unit weights are found by minimizing the squared difference between the demeaned outcome of the treated unit, its baseline mean, and the weighted average of the demeaned donor units’ outcomes. Importantly, the donor matrix is adjusted by the alignment coefficients. The more predictive the donor unit is of the target unit un the demeaned space, the higher the weight it will be assigned by the synthetic control optimization. The optimization problem for the unit weights is given by

$$
\underset{\mathbf{w} \in \mathcal{W}}{\operatorname*{argmin}} \left\| \left( \mathbf{y}_1 - \bar{y}_1 \mathbf{1}_T \right) - \widetilde{\mathbf{Y}}_0 (\mathbf{w} \circ \boldsymbol{\theta}) \right\|^2
$$

As before, our weights are restricted to lie in on the donor simplex. Through this two-stage process, the synthetic control is constructed by combining donor units in a way that most closely replicates the counterfactual outcome of the treated unit. The counterfactual is the intercept (the baseline difference) plus the dot product of the unit weights and the demeaned donor matrix.

The counterfactual is computed like

$$
\mathbf{y}_{1}^{\text{SRC}}(0) = \widetilde{\mathbf{Y}}_0 \cdot \mathbf{w} + \frac{1}{T_0} \left( \mathbf{1}^\top \mathbf{y}_1 - \mathbf{1}^\top \left( \widetilde{\mathbf{Y}}_0 \cdot \mathbf{w} \right) \right)
$$

# Implementing SRC in Python

```{python}
#| fig-align: center

import pandas as pd

from mlsynth.mlsynth import SRC

url = "https://raw.githubusercontent.com/jgreathouse9/mlsynth/refs/heads/main/basedata/smoking_data.csv"

# Feel free to change "smoking" with "basque" above in the URL

data = pd.read_csv(url)

config = {
    "df": data,
    "outcome": data.columns[2],
    "treat": data.columns[-1],
    "unitid": data.columns[0],
    "time": data.columns[1],
    "display_graphs": True,
    "save": False,
    "counterfactual_color": "blue"}

arco = SRC(config).fit()
```

and another

```{python}


import numpy as np
import cvxpy as cp
import matplotlib.pyplot as plt

# --- Simulation Parameters ---
n_units = 100
n_periods = 104
n_factors = 12
rho = 0.85
sigma = 1.25

treated_unit = 54
treatment_period = 76
treatment_effect = 15

# --- Simulate latent factors ---
np.random.seed(42)
common_factors = np.zeros((n_periods, n_factors))
common_factors[0, :] = np.random.normal(0, 1, n_factors)

for t in range(1, n_periods):
    common_factors[t, :] = rho * common_factors[t - 1, :] + np.random.normal(0, 1, n_factors)

factor_loadings = np.random.normal(0, 1, (n_units, n_factors))
error_terms = np.random.normal(0, sigma, (n_periods, n_units))

# --- Generate data ---
data = np.zeros((n_periods, n_units))
for i in range(n_units):
    base_level = np.random.randint(40, 80)
    data[:, i] = common_factors @ factor_loadings[i, :] + error_terms[:, i] + base_level

# Introduce treatment effect
data[treatment_period:, treated_unit] += treatment_effect

# --- Prepare synthetic control estimation ---

Y = data  # shape (T, J)
y_1 = Y[:, treated_unit]  # Treated unit
donor_mask = np.arange(n_units) != treated_unit
Y_0 = Y[:, donor_mask]    # Donor pool

T_pre = treatment_period
T_post = n_periods - T_pre
J = Y_0.shape[1]

# --- Pre-treatment data ---
Y_0_pre = Y_0[:T_pre, :]        # (T_pre, J)
y_1_pre = y_1[:T_pre]           # (T_pre,)
Y_0_pre_means = Y_0_pre.mean(axis=0)  # (J,)
y_1_pre_mean = y_1_pre.mean()       # scalar
Y_0_demeaned = Y_0_pre - Y_0_pre_means  # (T_pre, J)
y_1_demeaned = y_1_pre - y_1_pre_mean   # (T_pre,)

# --- Correctly Compute the Alignment Coefficients (theta) ---
# Step 1: Compute the demeaned matrices
# Step 2: Apply the formula: theta = (Y_0_demeaned.T @ Y_0_demeaned)^(-1) @ (Y_0_demeaned.T @ y_1_demeaned)

theta_hat = np.linalg.inv(Y_0_demeaned.T @ Y_0_demeaned) @ (Y_0_demeaned.T @ y_1_demeaned)  # (J,)

# --- Optimize weights (w) ---
w = cp.Variable(J)
objective = cp.Minimize(cp.norm(w @ Y_0_demeaned @ cp.multiply(theta_hat, y_1_demeaned-y_1_pre), 2)**2)  # Use demeaned target
constraints = [cp.sum(w) == 1, w >= 0]
problem = cp.Problem(objective, constraints)
problem.solve()

w_opt = w.value  # Optimal weights (J,)

# --- Construct counterfactual ---

# --- Step 5a: Construct post-treatment counterfactual ---
Y_0_post = Y_0[T_pre:, :]  # (T_post, J)
Y_0_post_demeaned = Y_0_post - Y_0_pre_means  # demean with pre-treatment means
y_1_counterfactual_post = y_1_pre_mean + Y_0_post_demeaned @ (w_opt)  # post-treatment counterfactual

# --- Step 5b: Construct pre-treatment counterfactual ---
y_1_counterfactual_pre = y_1_pre_mean + Y_0_demeaned @ (w_opt)  # pre-treatment counterfactual

# Combine both periods
y_1_synthetic = np.concatenate([y_1_counterfactual_pre, y_1_counterfactual_post])  # (T,)

# --- Plot results ---
plt.figure(figsize=(12, 6))
plt.plot(range(n_periods), y_1, label="Treated Unit (Observed)", color='blue')
plt.plot(range(n_periods), y_1_synthetic, label="Synthetic Control", color='red', linestyle='--')
plt.axvline(treatment_period, linestyle=':', color='gray', label="Treatment Starts")
plt.title("Synthetic Control with Alignment (Known DGP)")
plt.xlabel("Time")
plt.ylabel("Outcome")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()



```
