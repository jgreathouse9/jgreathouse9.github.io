---
title: 'Forward Synthetic Control Estimation'
date: 2025-03-31
categories: [Econometrics, Causal Inference, Data Science]
---
# Intro
Interpolation bias is a known issue in synthetic control methods. For valid counterfactual prediction, the donor units should be as similar as possible to the treated unit in the pre-treatment period. Selecting an appropriate donor pool is therefore critical, but this can be challenging in settings with many potential controls. This post introduces the [Forward Selected Synthetic Control Method](https://doi.org/10.1016/j.econlet.2024.111976), which applies Forward Selection to choose the donor pool for a synthetic control model before estimating out-of-sample predictions.

Let $\mathbb{R}$ denote the set of real numbers. A calligraphic letter, such as $\mathcal{S}$, represents a discrete set with cardinality $S = |\mathcal{S}|$. Let $t \in \mathbb{N}$ and $i \in \mathbb{N}$ represent indices for $T$ time periods and $N$ units, respectively. The pre-treatment period consists of consecutive time periods:

$$
\mathcal{T}_1 = \{1, 2, \dots, T_0\},
$$

with cardinality $T_1$, while the post-treatment period is given by:

$$
\mathcal{T}_2 = \{T_0 + 1, \dots, T\},
$$

with cardinality $T_2$. The treated unit is indexed by $i = 1$, while the remaining control units are indexed as $\mathcal{N}_0 = \{2, \dots, N\}$, with cardinality $N_0 = N - 1$. The observed outcome for unit $i$ at time $t$ is denoted by $y_{it}$. The outcome vector for the treated unit is:

$$
\mathbf{y}_1 = \begin{bmatrix} y_{11} & y_{12} & \cdots & y_{1T} \end{bmatrix}^\top \in \mathbb{R}^T,
$$

where each entry corresponds to the outcome of the treated unit at time $t$. The donor pool matrix, which concatenates the control unit outcome vectors, is defined as:

$$
\mathbf{Y}_0 \in \mathbb{R}^{T \times N_0}.
$$

The space of synthetic control weights is the $(N_0-1)$-dimensional probability simplex:

$$
\Delta^{N_0 - 1} = \left\{ \mathbf{w} \in \mathbb{R}_{\geq 0}^{N_0} : \|\mathbf{w}\|_1 = 1 \right\}.
$$

Now, consider a restricted donor pool chosen by forward selection. This consists of a strict subset of control units, $\mathcal{S} \subseteq \mathcal{N}_0$, with cardinality $k = |\mathcal{S}|$ where $k < N_0$. This subset induces a subsimplex:

$$
\Delta^{k - 1}(\mathcal{S}) = \left\{ \mathbf{w}' \in \mathbb{R}_{\geq 0}^{k} : \|\mathbf{w}'\|_1 = 1 \right\}.
$$

Since any feasible weight vector $\mathbf{w}' \in \Delta^{k-1}(\mathcal{S})$ can be embedded in $\Delta^{N_0-1}$ by setting the weights of all units outside $\mathcal{S}$ to zero, we have the natural inclusion:

$$
\Delta^{k - 1}(\mathcal{S}) \subseteq \Delta^{N_0 - 1}.
$$

The forward selection procedure iteratively constructs the donor pool by selecting control units that minimize pre-treatment mean squared error ($\text{MSE}$).

At each step, a new control unit is selected based on its contribution to reducing $\text{MSE}$, and the procedure terminates when no additional unit improves the fit.

The procedure begins by evaluating each donor unit $j \in \mathcal{N}_0$ independently. For each donor, we solve:

$$
\underset{\mathbf{w} \in \Delta^0(\{j\})}{\operatorname*{argmin}} \| \mathbf{y}_{1,\mathcal{T}_1} - \mathbf{Y}_{0,\mathcal{T}_1} \mathbf{w} \|_2^2.
$$

This computes one $\text{MSE}$ per donor unit. The donor with the lowest $\text{MSE}$, denoted as $j^\ast$, is selected as the first element of the donor set:

$$
 j^\ast = \underset{j \in \mathcal{N}_0}{\operatorname*{argmin}} \| \mathbf{y}_{1,\mathcal{T}_1} - \mathbf{Y}_{0,\mathcal{T}_1} \mathbf{w}^{(j)} \|_2^2.
$$

We define the initial donor set as:

$$
\mathcal{S}_1 = \{j^\ast\}.
$$

At each subsequent iteration $K$, we expand the donor pool by selecting an additional control unit. For each candidate donor $j \in \mathcal{N}_0 \setminus \mathcal{S}_{K-1}$, we solve:

$$
 j^\ast = \underset{j \in \mathcal{N}_0 \setminus \mathcal{S}_{K-1}}{\operatorname*{argmin}} \underset{\mathbf{w} \in \Delta^{K}(\mathcal{S}_{K-1} \cup \{j\})}{\operatorname*{min}} \| \mathbf{y}_{1,\mathcal{T}_1} - \mathbf{Y}_{0,\mathcal{T}_1} \mathbf{w} \|_2^2.
$$

The selected unit $j^\ast$ is added to the donor pool:

$$
\mathcal{S}_K = \mathcal{S}_{K-1} \cup \{j^{\ast}\}.
$$

The procedure terminates when $K= N_0$. The final donor pool is chosen as:

$$
\mathcal{S}^{\ast} = \underset{\mathcal{S}_i \in \{\mathcal{S}_1, \mathcal{S}_2, \dots, \mathcal{S}_K\}}{\operatorname*{argmin}} \ \text{MSE}(\mathcal{S}_i),
$$

or the subsimplex that minmizes the pre-treatment MSE. Note that not all donors in $\mathcal{S}^{\ast}$ necessarily receive positive weight in the final solution! These are just the units that are selected dor inclusion in the donor pool.


## Estimation in ```mlsynth```

As ususal, we begin by installing ```mlsynth```.

```bash
pip install -U git+https://github.com/jgreathouse9/mlsynth.git
```

And then we load the Prop 99 data and fit the model in the ususal ```mlsynth``` fashion.

```{python}
#| fig-align: center

import pandas as pd
from IPython.display import display, Markdown
from mlsynth.mlsynth import FSCM
url = "https://raw.githubusercontent.com/jgreathouse9/mlsynth/refs/heads/main/basedata/smoking_data.csv"
data = pd.read_csv(url)
config = {
    "df": data,
    "outcome": data.columns[2],
    "treat": data.columns[-1],
    "unitid": data.columns[0],
    "time": data.columns[1],
    "display_graphs": True,
    "save": False,
    "counterfactual_color": "red"}

arco = FSCM(config).fit()
```

After estimating, we can get the weights like

```{python}
weights_dict = arco['Weights'][0]
df = pd.DataFrame(list(weights_dict.items()), columns=['State', 'Weight'])
display(Markdown(df.to_markdown(index=False)))
```
These are the weights for all 17 units that were selected by the algorithm. As we can see, all of these even did not ultimately contribute to the synthetic control, with only 6 being assigned positive weight.
