---
title: 'What is a Synthetic Control?'
date: 2025-08-12
categories: [Econometrics, Causal Inference]
---

[Marketers](https://www.stellaheystella.com/blog/the-new-age-of-marketing-measurement-ai-incrementality-testing) and econometricians stress the importance of location selection for geo-testing/program evaluation for the effect of advertising interventions. Inherently speaking, the control locations we use directly impacts the quality of our counterfactual predictions, and therefore the ATT, [iROAS](https://imm.com/blog/iroas-incremental-return-on-ad-spend), or whatever metric we claim to care about. The reality is, you can't simply take an average of randomly selected control regions and compare them to the places you're increasing ad runs in. Therefore, researchers require systematic control group selection methods for the panel data setting where the randomzied controlled trial is not possible. Of course, one of these methods that's popular is the synthetic control method. But if you're reading this, you likely already know this. However, we need to take a step back. We need to ask ourselves more fundamentally what we think a synthetic control is as a concept. This happens in academia or industry all the time. My coworkers will ask me questions like, "Hey Jared, how do you view the whole constraints upon the weights for synthetic control methods? Why do we care, if at all, that the weights should be non-negative or add up to anything, and are there any rules regarding these ideas?" Usually people want to make some custom extension to the baseline algorithm, and want to know if they're breaking some seemingly sacrosanct rules. My answer is usually some variant of: *"Well, it depends on what you think a synthetic control is."* As it turns out, this is actually a non-trivial philosophical question that has no true answer.

Classically, synthetic control weights are viewed as a sparse vector, and plenty of academic work has [developed](https://doi.org/10.1080/15140326.2024.2361184) synthetic control methodologies from this perspective—focusing on sparsity for interpretability and parsimony. The point of sparsity, as [others](https://link.springer.com/article/10.1007/s10614-023-10471-7) (including me) [argue](https://link.springer.com/article/10.1007/s13209-021-00242-8) is for the resulting donors to be interpretable and economically similar to the units of interest (or more generally similar on latent factors that we cannot observe). Much work is dedicated to producing such descriptions of the SCM. [Others](https://doi.org/10.1111/jofi.13298) [argue](https://doi.org/10.48550/arXiv.2312.05593) [however](https://www.researchgate.net/profile/Yishu_Wang15/publication/386176990_L2-relaxation_for_Economic_Prediction/links/6747d57f876bd17778297bad/L2-relaxation-for-Economic-Prediction.pdf) for a completely different set of standards. The main contention seems to be that while sparsity offers interpretability and simplicity, it may not always be practical for capturing the complex relationships in real economic or business phenomena. Instead, they advocate for dense coefficient vectors that distribute weights more diffusely across donors, potentially improving predictive performance.

In my opinion, the general form of a synthetic control problem is some objective function where we weight donor units to best approximate the treated (set of) unit(s), with the choice of constraints reflecting both the econometric goals and domain-specific beliefs. The most general expression for this is

$$
\begin{aligned}
\min_{\mathbf{w}} \quad & \mathcal{L}\big( \mathbf{y}_1, \mathbf{Y}_0 \mathbf{w} \big) + \lambda \cdot \mathcal{R}(\mathbf{w}) \quad \text{subject to} \quad & \mathbf{w} \in \mathcal{W}
\end{aligned}
$$

where $\mathbf{y}_1$ is the vector of observed outcomes for the treated unit(s) during the pre-treatment period, $\mathbf{Y}_0$ is the matrix of outcomes for the donor pool units over the same period, and $\mathbf{w}$ is the vector of weights assigned to those donor units. The function $\mathcal{L}(\cdot, \cdot)$ represents the loss function measuring the discrepancy between the treated outcomes and the weighted combination of donors, commonly the squared error loss. The term $\mathcal{R}(\mathbf{w})$ is a regularization function that imposes additional structure or penalties on the weights to reflect beliefs or promote certain properties like sparsity or smoothness. The scalar $\lambda \geq 0$ controls the trade-off between fitting the data closely and respecting the regularization. Finally, the set $\mathcal{W}$ defines the feasible set of weights, encoding constraints such as non-negativity, sum-to-one, or other domain-specific restrictions. Notice that this setup is intended to be very very general. I have not yet taken a position on the nature of the weights or the specifics of the optimization problem.


# Application

To be more specific, let's use an example. Consider this plot of a growth rate variable, where the outcome is the number of products purchased when some advertising campaigns went into effect. The goal of an incrementality study is to estimate how the growth of sales would have evolved absent the ads. After all, this is how we determine if the ad spend was effective or if it was wasted—by estimating how much revenue we would have generated without any advertising. In this dataset, we observe 276 control units across 176 pre-treatment time periods. The key problem of interest is that there are very many control units to choose from. We cannot simply use the average of controls as a counterfactual estimate, as this presumes that the mean of this entire control group is similar enough (in both level and trend) to the treated unit of interest. As the figure suggests though, this is likely not true. While the growth rate does indeed remove seasonality elements, there are still trend, periodic, and perhaps [cyclical](https://arxiv.org/abs/2505.22388) differences to account for as well. Given this, it's likely the case that some reweighted average of these controls will mimic the treated unit much better than the pure average of the control units.


```{python}

#| fig-align: center
#| echo: false

import pandas as pd
import numpy as np
from mlsynth.utils.helperutils import sc_diagplot

df = pd.read_csv("Data/TNFEMP.csv")

# Step 1: Rename columns
df = df.rename(columns={
    "Katrina": "Treated",
    "MSA Title": "Unit",
    "YoY_NFE": "Outcome"
})
df["time"] = df["time"] - 12

# Step 2: Identify the treated unit name (before we overwrite it)
treated_unit = df.loc[df["Treated"] == 1, "Unit"].unique()[0]

# Step 3: Rename treated unit to 'Treated'
df.loc[df["Unit"] == treated_unit, "Unit"] = "Treated"

# Step 4: Rename all control units — make sure we exclude "Treated"
control_units = df["Unit"].unique()
control_units = [u for u in control_units if u != "Treated"]  # exclude treated
control_rename_map = {name: f"Control {i+1}" for i, name in enumerate(control_units)}
df["Unit"] = df["Unit"].replace(control_rename_map)

# Shared config
config = {
    "df": df,
    "outcome": "Outcome",
    "treat": "Treated",
    "unitid": "Unit",
    "time": "time",
    "display_graphs": False,
    "save": False,
    "counterfactual_color": ["red", "blue"]
}
sc_diagplot([config])
```

To this end, I fit a festival of models, some sparse, some sense. I fit the forward DID model (sparse), Forward SCM model (also sparse) and the robust PCA SCM model (sparse). For the dense models I estimate the $\ell_2$ panel data approach and the robust synthetic control (all these are [documented here](https://mlsynth.readthedocs.io/en/latest/)). I construct an ensemble of artificial counterfactual estimators by convexly combining the predictions of the base models. The goal is to produce a flexible estimator that balances the predictive accuracy of dense estimators with the interpretability and sparsity of sparse estimators. Let $M$ denote the number of candidate models in the ensemble. For each model $m = 1, \ldots, M$, we obtain a predicted counterfactual series $\widehat{Y}^{(m)}_{1,t}$ for the treated unit in the pre-treatment period $t \in \mathcal{T}_0$. We organize these into a matrix $\widehat{\mathbf{Y}}_0 \in \mathbb{R}^{T_0 \times M}$, where each column corresponds to one model's predicted values over the pre-treatment period. Let $\mathbf{Y}_{1,\text{pre}} \in \mathbb{R}^{T_0}$ denote the observed outcomes for the treated unit during the same period. We solve the following convex optimization problem to learn a set of model weights $\mathbf{w} \in \mathbb{R}^M$:

$$
\min_{\mathbf{w}} \left\| \mathbf{Y}_{1,\text{pre}} - \widehat{\mathbf{Y}}_0 \mathbf{w} \right\|_2^2 + \lambda \left\| \mathbf{w} \right\|_2^2
\quad \text{subject to} \quad \mathbf{w} \geq 0,\quad \sum_{m=1}^M w_m = 1.
$$

This is a ridge-penalized model averaging objective, constrained so that the weights are non-negative and sum to one. The penalty term $\lambda \left\| \mathbf{w} \right\|_2^2$ discourages over-reliance on any single model and promotes stability in the ensemble. We select the regularization parameter $\lambda$ via $K$-fold cross-validation on the pre-treatment period, minimizing the out-of-sample prediction error. The resulting weights $\widehat{\mathbf{w}}$ define the ensemble counterfactual:

$$
\widehat{Y}^{\text{ens}}_{1,t} = \sum_{m=1}^M \widehat{w}_m \widehat{Y}^{(m)}_{1,t}, \quad \text{for all } t.
$$

This procedure allows flexible borrowing of information across model classes, combining the sparse structure of subset-selected synthetic controls with the improved fit of regularized or dense variants, depending on which performs better in-sample. The ensemble is constrained to lie in the convex hull of the candidate model predictions.

```{python}
#| fig-align: center
#| echo: false

import pandas as pd
import numpy as np
import cvxpy as cp
from sklearn.model_selection import KFold
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib

# --- Plotting Setup ---
plot_theme_settings = {
    "figure.facecolor": "white",
    "figure.figsize": (11, 7),  # Slightly taller for vertical stacking
    "figure.dpi": 100,
    "figure.titlesize": 16,
    "figure.titleweight": "bold",
    "lines.linewidth": 1.2,
    "patch.facecolor": "#0072B2",
    "xtick.direction": "out",
    "ytick.direction": "out",
    "font.size": 14,
    "font.family": "sans-serif",
    "font.sans-serif": ["DejaVu Sans"],
    "axes.grid": True,
    "axes.facecolor": "white",
    "axes.linewidth": 0.1,
    "axes.titlesize": "large",
    "axes.titleweight": "bold",
    "axes.labelsize": "medium",
    "axes.labelweight": "bold",
    "axes.spines.top": False,
    "axes.spines.right": False,
    "axes.spines.left": False,
    "axes.spines.bottom": False,
    "axes.titlepad": 25,
    "axes.labelpad": 20,
    "grid.alpha": 0.1,
    "grid.linewidth": 0.5,
    "grid.color": "#000000",
    "legend.framealpha": 0.5,
    "legend.fancybox": True,
    "legend.borderpad": 0.5,
    "legend.loc": "best",
    "legend.fontsize": "small",
}

matplotlib.rcParams.update(plot_theme_settings)

# === Load and parse data ===
df = pd.read_csv(r"Data/scm_counterfactuals.csv")

extracted = {"sparse": {}, "dense": {}}

for col in df.columns:
    if col.startswith("sparse_"):
        model_name = col[len("sparse_"):]
        extracted["sparse"][model_name] = df[col].to_numpy()
    elif col.startswith("dense_"):
        model_name = col[len("dense_"):]
        extracted["dense"][model_name] = df[col].to_numpy()

if "CLUSTERSC" in extracted["dense"]:
    extracted["dense"]["PCR"] = extracted["dense"].pop("CLUSTERSC")
if "CLUSTERSC" in extracted["sparse"]:
    extracted["sparse"]["RPCA"] = extracted["sparse"].pop("CLUSTERSC")

T0 = (df["treatment"] == 0).sum()
y = df["observed"].to_numpy()
y_pre = y[:T0]

def fit_weights(y, Y0, lambda_):
    n, m = Y0.shape
    w = cp.Variable(m, nonneg=True)
    residual = y - Y0 @ w
    obj = cp.Minimize(cp.sum_squares(residual) + lambda_ * cp.sum_squares(w))
    constraints = [cp.sum(w) == 1]
    prob = cp.Problem(obj, constraints)
    prob.solve()
    return w.value

def cross_validate_lambda(y_pre, Y0_pre, lambdas, k_folds=5, random_state=42):
    kf = KFold(n_splits=k_folds, shuffle=True, random_state=random_state)
    avg_errors = []
    for lambda_ in lambdas:
        fold_errors = []
        for train_idx, test_idx in kf.split(y_pre):
            y_train, y_test = y_pre[train_idx], y_pre[test_idx]
            Y_train, Y_test = Y0_pre[train_idx], Y0_pre[test_idx]
            try:
                w_hat = fit_weights(y_train, Y_train, lambda_)
                y_pred = Y_test @ w_hat
                fold_errors.append(np.mean((y_test - y_pred) ** 2))
            except:
                fold_errors.append(np.inf)
        avg_errors.append(np.mean(fold_errors))
    best_lambda = lambdas[np.argmin(avg_errors)]
    return best_lambda, avg_errors

lambda_grid = np.logspace(-3, 2, 100)

results = {}
for group in ["sparse", "dense", "all"]:
    if group == "all":
        models = {**extracted["sparse"], **extracted["dense"]}
    else:
        models = extracted[group]

    model_names = list(models.keys())
    Y0 = np.column_stack([models[name] for name in model_names])
    Y0_pre = Y0[:T0]

    best_lambda, _ = cross_validate_lambda(y_pre, Y0_pre, lambda_grid)
    w_opt = fit_weights(y_pre, Y0_pre, best_lambda)
    y_hat_pre = Y0_pre @ w_opt
    rmse = np.sqrt(np.mean((y_pre - y_hat_pre) ** 2))

    results[group] = {
        "rmse": rmse,
        "lambda": best_lambda,
        "weights": dict(zip(model_names, w_opt)),
        "model_names": model_names,
        "Y0": Y0
    }

indiv_rmses = {}
for group in ["sparse", "dense"]:
    models = extracted[group]
    for name, series in models.items():
        rmse = np.sqrt(np.mean((y_pre - series[:T0]) ** 2))
        indiv_rmses[name] = rmse

for group in ["sparse", "dense", "all"]:
    indiv_rmses[f"{group} average"] = results[group]["rmse"]

sorted_names = sorted(indiv_rmses, key=lambda k: indiv_rmses[k], reverse=True)
sorted_rmses = [indiv_rmses[name] for name in sorted_names]

# === Plot stacked vertically (2 rows, 1 col) ===
fig = plt.figure(constrained_layout=True)
gs = gridspec.GridSpec(2, 1, height_ratios=[3, 2], hspace=0.3)

# Top plot: observed and model averages
ax0 = fig.add_subplot(gs[0])
ax0.plot(y, label="Observed", color="black", linewidth=3)

colors = {"sparse": "red", "dense": "blue", "all": "purple"}

for group in ["sparse", "dense", "all"]:
    if group == "all":
        models = {**extracted["sparse"], **extracted["dense"]}
    else:
        models = extracted[group]

    model_names = list(models.keys())
    Y0 = np.column_stack([models[name] for name in model_names])

    w = np.array([results[group]["weights"].get(name, 0) for name in model_names])
    y_hat = Y0 @ w

    ax0.plot(y_hat, label=f"{group.capitalize()} Model Avg", color=colors[group], linewidth=1.5)

ax0.axvline(x=T0-1, color="grey", linestyle="--", label="Treatment Start")
ax0.set_xlabel("Time")
ax0.set_ylabel("Outcome (YoY Growth)")
ax0.set_title("Observed vs Model-Averaged Synthetic Controls")
ax0.legend()
ax0.text(50, -10, f"Sparse RMSE: {results['sparse']['rmse']:.4f}", color="red", fontsize=12)
ax0.text(50, -22, f"Dense RMSE: {results['dense']['rmse']:.4f}", color="blue", fontsize=12)

# Bottom plot: horizontal RMSE bar chart
ax1 = fig.add_subplot(gs[1])
bars = ax1.barh(range(len(sorted_names)), sorted_rmses, color="blue")
ax1.set_yticks(range(len(sorted_names)))
ax1.set_yticklabels(sorted_names, rotation=45)
ax1.invert_yaxis()
ax1.set_xlabel("Pre-treatment RMSE")

for bar, rmse in zip(bars, sorted_rmses):
    width = bar.get_width()
    ax1.text(width + 0.01, bar.get_y() + bar.get_height()/2, f"{rmse:.3f}",
             va='center', fontsize=9)

plt.show()
```

The results from the model averaging procedure reveal clear trade-offs between sparsity and predictive accuracy. In the sparse model average, the optimal penalty parameter is $\lambda = 1.7074$, leading to a pre-treatment RMSE of $0.5028$. Within this specification, the FSCM model receives the most weight ($0.2085$), followed by FDID ($0.7915$), while RPCA is unused. In contrast, the dense model average achieves a substantially better fit (RMSE $= 0.3085$) with a much smaller penalty ($\lambda = 0.0010$), allocating nearly all weight to PCR ($0.9966$) and very little to PDA ($0.0034$). The full model average, which includes both sparse and dense estimators, also selects $\lambda = 0.0010$ and reaches the same RMSE of $0.3085$, but nearly all weight again falls on PCR ($0.9927$), with RPCA contributing marginally ($0.0073$) and all others excluded.

These results underscore a key econometric tension: while dense methods often achieve superior in-sample fit, they can obscure the role of individual donors and reduce interpretability. Sparse methods like FSCM and FDID provide clearer narratives but may underperform in terms of match quality. In settings where both approaches yield similar outcomes—as they do here—the choice between them ultimately depends on the econometrician’s priorities. If transparency and donor interpretability are paramount, sparse models may be preferred. If minimizing pre-treatment error is the guiding objective, dense models may be more appropriate. In this sense, model selection becomes not just a statistical exercise, but a philosophical one as well.

In some ways, this also illustrates why I wrote mlsynth. I do not claim to have the best models or know all of the secrets to solve one's modeling needs; rather, I program models that I think are useful, in certain cases. The point of the mlsynth library is to allow researchers to compare and contrast these different models together all in one singular grammar, without needing to be bogged down in different softwares and syntaxes. [Cool](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=5141328) [stuff](https://arxiv.org/abs/2408.09271) [happens](https://arxiv.org/pdf/2508.05604) [all the time](https://arxiv.org/abs/2503.06454) with these methods, and the only way for them to be used, and used more often, is by providing researchers with a simple framework by which to generate these counterfactuals in settings they care about.


